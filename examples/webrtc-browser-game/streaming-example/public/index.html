<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Streaming Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        h1 {
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        #videoContainer {
            background: #000;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            overflow: hidden;
            max-width: 800px;
            width: 100%;
            position: relative;
        }
        
        #remoteVideo {
            width: 100%;
            height: auto;
            display: block;
        }
        
        #controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        #startBtn {
            background: #4CAF50;
            color: white;
        }
        
        #startBtn:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }
        
        #stopBtn {
            background: #f44336;
            color: white;
        }
        
        #stopBtn:hover {
            background: #da190b;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(244, 67, 54, 0.3);
        }
        
        #stopBtn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        #status {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            text-align: center;
            max-width: 800px;
            width: 100%;
        }
        
        .status-connected {
            color: #4CAF50;
        }
        
        .status-disconnected {
            color: #f44336;
        }
        
        .status-connecting {
            color: #ff9800;
        }
        
        #stats {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            font-family: monospace;
            max-width: 800px;
            width: 100%;
            display: none;
        }
        
        #stats.visible {
            display: block;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #latencyIndicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
        }
        
        .good-latency { color: #4CAF50; }
        .medium-latency { color: #ff9800; }
        .bad-latency { color: #f44336; }
    </style>
</head>
<body>
    <h1>üé• WebRTC Server Streaming</h1>
    
    <div id="videoContainer">
        <video id="remoteVideo" autoplay playsinline></video>
        <div id="latencyIndicator" style="display: none;">
            Latency: <span id="latencyValue">0ms</span>
        </div>
    </div>
    
    <div id="controls">
        <button id="startBtn" onclick="startStream()">‚ñ∂Ô∏è Start Stream</button>
        <button id="stopBtn" onclick="stopStream()" disabled>‚èπÔ∏è Stop Stream</button>
        <button onclick="toggleStats()">üìä Toggle Stats</button>
    </div>
    
    <div id="status">
        <span class="status-disconnected">‚ö™ Disconnected</span>
    </div>
    
    <div id="stats">
        <h3>üìä Stream Statistics</h3>
        <div class="stat-row">
            <span>Video Codec:</span>
            <span id="videoCodec">-</span>
        </div>
        <div class="stat-row">
            <span>Resolution:</span>
            <span id="resolution">-</span>
        </div>
        <div class="stat-row">
            <span>Frame Rate:</span>
            <span id="frameRate">-</span>
        </div>
        <div class="stat-row">
            <span>Bitrate:</span>
            <span id="bitrate">-</span>
        </div>
        <div class="stat-row">
            <span>Packets Lost:</span>
            <span id="packetsLost">-</span>
        </div>
        <div class="stat-row">
            <span>Jitter:</span>
            <span id="jitter">-</span>
        </div>
    </div>

    <script>
        let ws = null;
        let pc = null;
        let statsInterval = null;
        let isStreaming = false;

        // Connect to WebSocket server
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}`;
            
            updateStatus('connecting', 'üü° Connecting...');
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                console.log('‚úÖ WebSocket connected');
                updateStatus('connected', 'üü¢ Connected to server');
            };
            
            ws.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                await handleSignaling(data);
            };
            
            ws.onclose = () => {
                console.log('‚ùå WebSocket disconnected');
                updateStatus('disconnected', 'üî¥ Disconnected from server');
                if (isStreaming) {
                    stopStream();
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('disconnected', 'üî¥ Connection error');
            };
        }

        // Start streaming
        async function startStream() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('Not connected to server. Please refresh the page.');
                return;
            }
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            // Create peer connection
            pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            });
            
            // Handle incoming tracks
            pc.ontrack = (event) => {
                console.log('üìπ Received remote track');
                const video = document.getElementById('remoteVideo');
                video.srcObject = event.streams[0];
                
                // Show latency indicator
                document.getElementById('latencyIndicator').style.display = 'block';
            };
            
            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate
                    }));
                }
            };
            
            // Handle connection state
            pc.onconnectionstatechange = () => {
                console.log('Connection state:', pc.connectionState);
                if (pc.connectionState === 'connected') {
                    updateStatus('connected', 'üü¢ Streaming');
                    startStatsCollection();
                    isStreaming = true;
                } else if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                    stopStream();
                }
            };
            
            // Request stream from server
            ws.send(JSON.stringify({ type: 'start-stream' }));
        }

        // Stop streaming
        function stopStream() {
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'stop-stream' }));
            }
            
            if (pc) {
                pc.close();
                pc = null;
            }
            
            const video = document.getElementById('remoteVideo');
            video.srcObject = null;
            
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            
            document.getElementById('latencyIndicator').style.display = 'none';
            updateStatus('connected', 'üü¢ Connected to server');
            isStreaming = false;
        }

        // Handle WebRTC signaling
        async function handleSignaling(data) {
            switch (data.type) {
                case 'offer':
                    await pc.setRemoteDescription(data.offer);
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    
                    ws.send(JSON.stringify({
                        type: 'answer',
                        answer: answer
                    }));
                    break;
                    
                case 'ice-candidate':
                    await pc.addIceCandidate(data.candidate);
                    break;
                    
                case 'error':
                    console.error('Server error:', data.message);
                    alert('Server error: ' + data.message);
                    stopStream();
                    break;
            }
        }

        // Update connection status
        function updateStatus(state, message) {
            const statusEl = document.getElementById('status');
            statusEl.className = '';
            statusEl.innerHTML = message;
            
            if (state === 'connected') {
                statusEl.classList.add('status-connected');
            } else if (state === 'disconnected') {
                statusEl.classList.add('status-disconnected');
            } else if (state === 'connecting') {
                statusEl.innerHTML = message + '<span class="loading"></span>';
                statusEl.classList.add('status-connecting');
            }
        }

        // Collect and display statistics
        function startStatsCollection() {
            statsInterval = setInterval(async () => {
                if (!pc) return;
                
                const stats = await pc.getStats();
                let videoStats = null;
                let inboundStats = null;
                
                stats.forEach(report => {
                    if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                        inboundStats = report;
                    }
                    if (report.type === 'track' && report.kind === 'video') {
                        videoStats = report;
                    }
                });
                
                if (inboundStats) {
                    // Update stats display
                    document.getElementById('videoCodec').textContent = inboundStats.codecId || 'Unknown';
                    document.getElementById('frameRate').textContent = `${inboundStats.framesPerSecond || 0} fps`;
                    document.getElementById('packetsLost').textContent = inboundStats.packetsLost || 0;
                    document.getElementById('jitter').textContent = `${(inboundStats.jitter * 1000).toFixed(2)} ms`;
                    
                    // Calculate bitrate
                    if (window.lastBytesReceived) {
                        const bitrate = ((inboundStats.bytesReceived - window.lastBytesReceived) * 8) / 1000;
                        document.getElementById('bitrate').textContent = `${bitrate.toFixed(2)} kbps`;
                    }
                    window.lastBytesReceived = inboundStats.bytesReceived;
                }
                
                if (videoStats) {
                    document.getElementById('resolution').textContent = 
                        `${videoStats.frameWidth || 0}x${videoStats.frameHeight || 0}`;
                }
                
                // Estimate latency (simplified)
                const latency = await estimateLatency();
                updateLatencyIndicator(latency);
                
            }, 1000);
        }

        // Estimate latency using data channel ping
        async function estimateLatency() {
            // In a real implementation, you'd use a data channel for accurate RTT measurement
            // This is a simplified estimation based on connection quality
            if (!pc) return 0;
            
            const stats = await pc.getStats();
            let totalRtt = 0;
            let count = 0;
            
            stats.forEach(report => {
                if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                    if (report.currentRoundTripTime) {
                        totalRtt += report.currentRoundTripTime * 1000; // Convert to ms
                        count++;
                    }
                }
            });
            
            return count > 0 ? Math.round(totalRtt / count) : 0;
        }

        // Update latency indicator
        function updateLatencyIndicator(latency) {
            const indicator = document.getElementById('latencyIndicator');
            const value = document.getElementById('latencyValue');
            
            value.textContent = `${latency}ms`;
            
            // Color code based on latency
            value.className = '';
            if (latency < 50) {
                value.classList.add('good-latency');
            } else if (latency < 150) {
                value.classList.add('medium-latency');
            } else {
                value.classList.add('bad-latency');
            }
        }

        // Toggle statistics display
        function toggleStats() {
            const stats = document.getElementById('stats');
            stats.classList.toggle('visible');
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            connectWebSocket();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (isStreaming) {
                stopStream();
            }
            if (ws) {
                ws.close();
            }
        });
    </script>
</body>
</html>