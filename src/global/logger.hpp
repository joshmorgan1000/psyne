// DO NOT EDIT THIS FILE UNDER ANY CIRCUMSTANCES. If you are stuck because of it
// STOP IMMEDIATELY AND ASK FOR HELP.
#pragma once

/**
 * @file logger.hpp
 * @brief Thread-safe logging utilities with progress bar support
 * @author Psyne Contributors
 * @date 2025
 *
 * This file provides a comprehensive logging system with:
 * - Multiple log levels (trace, debug, info, warn, error)
 * - Thread-safe operation
 * - Progress bar support for long-running operations
 * - Colored output for better readability
 * - Per-thread context tracking
 */
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <cstdint>
#include <iomanip>
#include <iostream>
#include <memory>
#include <mutex>
#include <random>
#include <shared_mutex>
#include <sstream>
#include <string>
#include <sys/ioctl.h>
#include <thread>
#include <unistd.h>
#include <unordered_map>
#include <vector>

namespace psyne {

// DO NOT EDIT THIS FILE UNDER ANY CIRCUMSTANCES. If you are stuck because of it
// STOP IMMEDIATELY AND ASK FOR HELP.

/**
 * @brief Returns the epoch timestamp in milliseconds.
 *
 * Static so it can be called by other classes that might need an epoch
 * timestamp for various reasons.
 *
 * @return uint64_t The epoch timestamp in milliseconds
 */
static uint64_t getCurrentTimestamp() {
    return std::chrono::duration_cast<std::chrono::milliseconds>(
               std::chrono::system_clock::now().time_since_epoch())
        .count();
}

/**
 * @brief Returns the current time in milliseconds (alias for
 * getCurrentTimestamp)
 * @return uint64_t The current timestamp in milliseconds
 */
inline static uint64_t get_now() {
    return std::chrono::duration_cast<std::chrono::milliseconds>(
               std::chrono::system_clock::now().time_since_epoch())
        .count();
}

/**
 * @brief Get formatted timestamp string for logging
 * @return std::string Formatted timestamp
 */
inline static std::string GetTimestamp() {
    auto now = std::chrono::system_clock::now();
    auto time_t = std::chrono::system_clock::to_time_t(now);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                  now.time_since_epoch()) %
              1000;

    std::ostringstream oss;
    oss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
    oss << '.' << std::setfill('0') << std::setw(3) << ms.count();
    return oss.str();
}

/**
 * @brief Format duration in human-readable format
 * @param duration_ms Duration in milliseconds
 * @return std::string Formatted duration string
 */
inline static std::string FormatDuration(uint64_t duration_ms) {
    if (duration_ms < 1000) {
        return std::to_string(duration_ms) + "ms";
    } else if (duration_ms < 60000) {
        return std::to_string(duration_ms / 1000.0) + "s";
    } else if (duration_ms < 3600000) {
        uint64_t minutes = duration_ms / 60000;
        uint64_t seconds = (duration_ms % 60000) / 1000;
        return std::to_string(minutes) + "m " + std::to_string(seconds) + "s";
    } else {
        uint64_t hours = duration_ms / 3600000;
        uint64_t minutes = (duration_ms % 3600000) / 60000;
        return std::to_string(hours) + "h " + std::to_string(minutes) + "m";
    }
}

/**
 * @brief High precision timestamp for performance measurements
 * @return uint64_t Nanoseconds since epoch
 */
inline static uint64_t getHighPrecisionTimestamp() {
    return std::chrono::duration_cast<std::chrono::nanoseconds>(
               std::chrono::high_resolution_clock::now().time_since_epoch())
        .count();
}

/**
 * @brief Get microsecond precision timestamp
 * @return uint64_t Microseconds since epoch
 */
inline static uint64_t getMicrosecondTimestamp() {
    return std::chrono::duration_cast<std::chrono::microseconds>(
               std::chrono::system_clock::now().time_since_epoch())
        .count();
}

// Thread-safe random number generation using thread-local generators
class ThreadSafeRandom {
private:
    // Thread-local random engine - each thread gets its own generator
    static thread_local std::mt19937 rng_;
    static thread_local bool initialized_;

    static void ensure_initialized() {
        if (!initialized_) {
            // Seed with a combination of thread ID and high-resolution time
            auto seed =
                std::hash<std::thread::id>{}(std::this_thread::get_id()) ^
                static_cast<uint64_t>(std::chrono::high_resolution_clock::now()
                                          .time_since_epoch()
                                          .count());
            rng_.seed(static_cast<std::mt19937::result_type>(seed));
            initialized_ = true;
        }
    }

public:
    // Thread-safe random integer generation
    static uint32_t random_uint32() {
        ensure_initialized();
        return rng_();
    }

    // Thread-safe random integer in range [0, max)
    static uint32_t random_uint32(uint32_t max) {
        if (max == 0)
            return 0;
        ensure_initialized();
        std::uniform_int_distribution<uint32_t> dist(0, max - 1);
        return dist(rng_);
    }

    // Thread-safe random byte generation
    static uint8_t random_byte() {
        ensure_initialized();
        std::uniform_int_distribution<uint8_t> dist(0, 255);
        return dist(rng_);
    }
};

// Thread-local static member definitions
inline thread_local std::mt19937 ThreadSafeRandom::rng_;
inline thread_local bool ThreadSafeRandom::initialized_{false};

/**
 * Thread-safe replacement for the original random_string function
 * Ensures first character is a letter (a-z) for compatibility
 */
inline std::string random_string(size_t length) {
    static constexpr char alphanum[] = "0123456789abcdefghijklmnopqrstuvwxyz";
    static constexpr size_t alphanum_size =
        sizeof(alphanum) - 1;                  // -1 for null terminator
    static constexpr size_t letter_start = 10; // Start of letters in alphanum

    if (length == 0)
        return "";

    std::string result;
    result.reserve(length);

    // Ensure first char is a letter (a-z) for compatibility with original
    // behavior
    result +=
        alphanum[ThreadSafeRandom::random_uint32(alphanum_size - letter_start) +
                 letter_start];

    // Fill remaining characters with any alphanumeric character
    for (size_t i = 1; i < length; ++i) {
        result += alphanum[ThreadSafeRandom::random_uint32(alphanum_size)];
    }

    return result;
}

/**
 * Generate a random string of specified length with alphanumeric characters
 * Used for ID generation in progress bars and other utilities
 */
inline std::string generate_random_id(size_t length = 32) {
    static constexpr char chars[] =
        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    static constexpr size_t chars_size = sizeof(chars) - 1;

    std::string result;
    result.reserve(length);

    for (size_t i = 0; i < length; ++i) {
        result += chars[ThreadSafeRandom::random_uint32(chars_size)];
    }

    return result;
}

/**
 * @struct ProgressBar
 * @brief Progress bar state for tracking long-running operations
 *
 * Maintains the state of a progress bar including its position,
 * progress percentage, and visual parameters.
 */
struct ProgressBar {
    std::string id;
    std::string thread_name;
    std::string header;
    std::string start_time_str;
    float progress;
    int width;
    unsigned long start_line;
    uint64_t start_time;
};

enum class LogLevel {
    TRACE = 0, ///< Most verbose - trace execution flow
    DEBUG = 1, ///< Debug information for development
    INFO = 2,  ///< General information messages
    WARN = 3,  ///< Warning messages for potential issues
    ERROR = 4  ///< Error messages only
};

/**
 * @struct GlobalContext
 * @brief Global context for thread-safe logging and progress tracking
 *
 * This singleton structure maintains the global state for the logging system,
 * including all active progress bars, log history, and thread-specific
 * contexts. It ensures thread-safe operation through careful use of mutexes.
 */
struct GlobalContext {
    std::atomic<uint64_t> stdout_current_line{0};
    std::unique_lock<std::mutex> stdout_thread_lock;
    static thread_local std::string thread_context;
    std::mutex stdout_mutex;
    std::condition_variable stdout_cv;
    std::atomic<uint64_t> next_ticket{0};
    std::atomic<uint64_t> currently_serving{0};
    std::atomic<uint64_t> threadCounter{0};
    std::atomic<bool> stopFlag{false};
    std::atomic<bool> standalone{true};
    std::shared_mutex progress_mutex;
    std::atomic<bool> banner_animation_done{true};
    std::shared_ptr<std::thread> crypto_hash_init_ptr;
    size_t num_cpu_cores = std::thread::hardware_concurrency();
    static constexpr uint8_t initialObfuscation[4] = {0x13, 0x6E, 0x68, 0x70};
    LogLevel global_log_level = LogLevel::ERROR;
    std::unordered_map<std::string, ProgressBar> progress_bars;
};

inline GlobalContext &getGlobalContext() {
    static GlobalContext instance;
    return instance;
}

inline thread_local std::string GlobalContext::thread_context{};
inline thread_local std::string &thread_context =
    getGlobalContext().thread_context;

// Your ticket-based stdout locking system - preserved exactly
static inline void stdout_lock() {
    unsigned long ticket = getGlobalContext().next_ticket.fetch_add(1);
    getGlobalContext().stdout_thread_lock =
        std::unique_lock<std::mutex>(getGlobalContext().stdout_mutex);
    getGlobalContext().stdout_cv.wait(
        getGlobalContext().stdout_thread_lock, [&]() {
            return ticket == getGlobalContext().currently_serving.load();
        });
}

static inline void stdout_unlock() {
    getGlobalContext().currently_serving.fetch_add(1);
    getGlobalContext().stdout_cv.notify_all();
    getGlobalContext().stdout_thread_lock.unlock();
}

// Progress bar update logic - your exact implementation
static inline void UpdateProgressBar(const ProgressBar &bar) {
    float progress = bar.progress;
    int filled_width = static_cast<int>(bar.width * progress);
    stdout_lock();
    int lines_down =
        getGlobalContext().stdout_current_line.load() - bar.start_line;
    std::ostringstream oss;
    for (int i = 0; i < lines_down; i++) {
        oss << "\033[1A";
    }
    oss << "\033[2K" << "\r";
    if (progress >= 1.0f) {
        uint64_t duration = getCurrentTimestamp() - bar.start_time;
        oss << bar.start_time_str << " [INFO ] [" << bar.thread_name << "] "
            << bar.header << " Completed in " << FormatDuration(duration);
        getGlobalContext().progress_bars.erase(bar.id);
    } else {
        uint64_t elapsed_time = getCurrentTimestamp() - bar.start_time;
        uint64_t estimated_time_remaining =
            (elapsed_time / progress) - elapsed_time;
        std::string time_remaining = FormatDuration(estimated_time_remaining);
        oss << bar.start_time_str << " [INFO ] [" << bar.thread_name << "] "
            << bar.header << " [" << std::string(filled_width, '=')
            << std::string(bar.width - filled_width, ' ') << "] " << std::fixed
            << std::setprecision(1) << (progress * 100)
            << "% est:" << time_remaining;
    }
    oss << "\r";
    for (int i = 0; i < lines_down; i++) {
        oss << "\033[1B";
    }
    std::cout << oss.str() << "\r";
    std::cout.flush();
    stdout_unlock();
}

static inline void RedrawAllProgressBars() {
    std::unique_lock lock(getGlobalContext().progress_mutex);
    for (const auto &[id, bar] : getGlobalContext().progress_bars) {
        UpdateProgressBar(bar);
    }
}

// Your progress bar creation logic - preserved exactly with thread-safe random
// ID
static inline std::function<void(float)>
log_progress(const std::string &header,
             const std::string &thread_name = thread_context) {
    // Use thread-safe random ID generation
    std::string random_id = generate_random_id(32);
    std::thread log_progress_bar_thread([header, random_id, thread_name]() {
        thread_context = thread_name;
        struct winsize w;
        ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
        int term_width = w.ws_col > 0 ? w.ws_col : 80;
        int bar_width = term_width - 50 - header.length() - 38;
        std::string timestamp = GetTimestamp();
        std::ostringstream oss;
        oss << timestamp << " [INFO ] [" << thread_context << "] " << header
            << " [" << std::string(bar_width, ' ') << "] 0%\n";
        stdout_lock();
        std::cout << oss.str() << "\r";
        std::cout.flush();
        {
            std::unique_lock lock(getGlobalContext().progress_mutex);
            ProgressBar progress_bar_instance = {
                random_id,
                thread_context,
                header,
                timestamp,
                0.0f,
                bar_width,
                getGlobalContext().stdout_current_line.load(),
                getCurrentTimestamp()};
            getGlobalContext().progress_bars[random_id] = progress_bar_instance;
        }
        getGlobalContext().stdout_current_line += 1;
        stdout_unlock();
    });
    log_progress_bar_thread.detach();
    return [random_id](float progress) mutable {
        std::unique_lock lock(getGlobalContext().progress_mutex);
        if (getGlobalContext().progress_bars.find(random_id) ==
            getGlobalContext().progress_bars.end()) {
            return;
        }
        getGlobalContext().progress_bars[random_id].progress = progress;
        UpdateProgressBar(getGlobalContext().progress_bars[random_id]);
    };
}

// Your concept definitions for logging - preserved exactly
template <typename T>
concept Streamable = requires(std::ostream &os, T const &t) {
    { os << t } -> std::convertible_to<std::ostream &>;
};

template <typename T>
concept HasToJson = requires(T t) {
    { t.toJson() } -> std::convertible_to<std::string>;
};

template <typename T>
concept HasToString = requires(T t) {
    { t.toString() } -> std::convertible_to<std::string>;
};

template <typename T>
concept EssentiallyStreamable = Streamable<T> || HasToJson<T> || HasToString<T>;

// Your parameter concatenation logic - preserved exactly
template <typename T>
    requires Streamable<T>
inline static void
concat_multi_parameter_inputs(std::stringstream &currentstream, T first) {
    if constexpr (Streamable<T>)
        currentstream << first;
    else if constexpr (HasToJson<T>)
        currentstream << first.toJson().dump();
    else if constexpr (HasToString<T>)
        currentstream << first.toString();
}

template <typename T, typename... Args>
    requires Streamable<T>
static void concat_multi_parameter_inputs(std::stringstream &currentstream,
                                          T first, Args... args) {
    if constexpr (Streamable<T>)
        currentstream << first;
    else if constexpr (HasToJson<T>)
        currentstream << first.toJson().dump();
    else if constexpr (HasToString<T>)
        currentstream << first.toString();
    if constexpr (sizeof...(args) > 0) {
        concat_multi_parameter_inputs(currentstream, args...);
    }
}

// Log level setter/getter - internal implementation
inline static void set_internal_log_level(LogLevel level) {
    getGlobalContext().global_log_level = level;
}

// Your logging functions - preserved EXACTLY with stringstream->cout->mutex
// design
template <typename T, typename... Args>
    requires EssentiallyStreamable<T>
static void log_info(T first, Args... args) {
    std::stringstream oss;
    oss << GetTimestamp() << " [INFO ] [" << thread_context << "] ";
    concat_multi_parameter_inputs(oss, first, args...);
    oss << "\n";
    int lines = 0;
    int char_count = 0;
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    int term_width = w.ws_col > 0 ? w.ws_col : 80;
    for (char c : oss.str()) {
        char_count++;
        if (char_count % term_width == 0)
            lines++;
        if (c == '\n') {
            lines++;
            char_count = 0;
        }
    }
    std::cout << oss.str();
    std::cout.flush();
    getGlobalContext().stdout_current_line += lines;
    RedrawAllProgressBars();
}

template <typename T, typename... Args>
    requires EssentiallyStreamable<T>
static void log_error(T first, Args... args) {
    std::stringstream oss;
    oss << "\033[1;31m";
    oss << GetTimestamp() << " [ERROR] [" << thread_context << "] ";
    concat_multi_parameter_inputs(oss, first, args...);
    oss << "\n";
    int lines = 0;
    int char_count = 0;
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    int term_width = w.ws_col > 0 ? w.ws_col : 80;
    for (char c : oss.str()) {
        char_count++;
        if (char_count % term_width == 0)
            lines++;
        if (c == '\n') {
            lines++;
            char_count = 0;
        }
    }
    oss << "\033[0m";
    stdout_lock();
    std::cout << oss.str();
    std::cout.flush();
    getGlobalContext().stdout_current_line += lines;
    stdout_unlock();
    RedrawAllProgressBars();
}

template <typename T, typename... Args>
    requires EssentiallyStreamable<T>
static void log_warn(T first, Args... args) {
    std::stringstream oss;
    oss << "\033[1;33m";
    oss << GetTimestamp() << " [WARN ] [" << thread_context << "] ";
    concat_multi_parameter_inputs(oss, first, args...);
    oss << "\n";
    int lines = 0;
    int char_count = 0;
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    int term_width = w.ws_col > 0 ? w.ws_col : 80;
    for (char c : oss.str()) {
        char_count++;
        if (char_count % term_width == 0)
            lines++;
        if (c == '\n') {
            lines++;
            char_count = 0;
        }
    }
    oss << "\033[0m";
    // stdout_lock();
    std::cout << oss.str();
    std::cout.flush();
    getGlobalContext().stdout_current_line += lines;
    // stdout_unlock();
    RedrawAllProgressBars();
}

template <typename T, typename... Args>
    requires EssentiallyStreamable<T>
static void log_debug(T first, Args... args) {
    if (getGlobalContext().global_log_level > LogLevel::DEBUG) {
        return;
    }
    std::stringstream oss;
    oss << "\033[1;34m";
    oss << GetTimestamp() << " [DEBUG] [" << thread_context << "] ";
    concat_multi_parameter_inputs(oss, first, args...);
    oss << "\n";
    int lines = 0;
    int char_count = 0;
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    int term_width = w.ws_col > 0 ? w.ws_col : 80;
    for (char c : oss.str()) {
        char_count++;
        if (char_count % term_width == 0)
            lines++;
        if (c == '\n') {
            lines++;
            char_count = 0;
        }
    }
    oss << "\033[0m";
    stdout_lock();
    std::cout << oss.str();
    std::cout.flush();
    getGlobalContext().stdout_current_line += lines;
    stdout_unlock();
    RedrawAllProgressBars();
}

template <typename T, typename... Args>
    requires EssentiallyStreamable<T>
static void log_trace(T first, Args... args) {
    if (getGlobalContext().global_log_level > LogLevel::TRACE) {
        return;
    }
    std::stringstream oss;
    oss << "\033[1;34m";
    oss << GetTimestamp() << " [TRACE] [" << thread_context << "] ";
    concat_multi_parameter_inputs(oss, first, args...);
    oss << "\n";
    int lines = 0;
    int char_count = 0;
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    int term_width = w.ws_col > 0 ? w.ws_col : 80;
    for (char c : oss.str()) {
        char_count++;
        if (char_count % term_width == 0)
            lines++;
        if (c == '\n') {
            lines++;
            char_count = 0;
        }
    }
    oss << "\033[0m";
    stdout_lock();
    std::cout << oss.str();
    std::cout.flush();
    getGlobalContext().stdout_current_line += lines;
    stdout_unlock();
    RedrawAllProgressBars();
}

} // namespace psyne